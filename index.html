<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Українські переклади модів</title>
    <link rel="icon" href="data:,">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        h1 { text-align: center; }
        #search-container { text-align: center; margin-bottom: 20px; }
        #search-input, select { padding: 10px; font-size: 16px; border: 1px solid #ddd; border-radius: 4px; margin: 0 5px 10px 0; }
        .mod-list { display: flex; flex-wrap: wrap; justify-content: center; }
        .mod-card { background: white; border: 1px solid #ddd; border-radius: 8px; margin: 10px; padding: 15px; width: 220px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .mod-card img { width: 66.67%; height: auto; border-radius: 4px; display: block; margin: 0 auto; }
        .mod-card h2 { margin: 10px 0; }
        .mod-card p { margin: 5px 0; }
        button { background-color: #4CAF50; color: white; border: none; padding: 10px 15px; cursor: pointer; border-radius: 4px; margin-top: 5px; }
        button:hover { background-color: #45a049; }
        .hidden { display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
<h1>Українські переклади модів (як Modrinth)</h1>
<div id="search-container">
    <input type="text" id="search-input" placeholder="Пошук по назві мода..."><br>
    <select id="filter-version">
        <option value="">Всі версії</option>
    </select>
    <select id="filter-core">
        <option value="">Всі ядра</option>
    </select>
    <select id="filter-author">
        <option value="">Всі автори</option>
    </select>
</div>
<button id="combine-open">Об'єднати мод</button>
<div id="mod-list" class="mod-list"></div>

<!-- Модальні вікна залишаються без змін -->

<script>
const repoOwner = 'halitflyn';
const repoName = 'ua';
const basePath = 'mods';
const rawBaseUrl = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/main`;

// Масиви для фільтрів
let allVersions = new Set();
let allCores = new Set();
let allAuthors = new Set();

// Зберігаємо дані про моди для подальшого використання
let modsData = [];

async function fetchRepoContents(path) {
    const url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${path}`;
    try {
        const response = await fetch(url);
        if (!response.ok) return null;
        return await response.json();
    } catch (e) { console.error(`Error fetching contents for ${path}:`, e); return null; }
}

async function loadMods() {
    const mods = await fetchRepoContents(basePath);
    if (!mods || !Array.isArray(mods)) return;
    const modListDiv = document.getElementById('mod-list');

    for (const mod of mods) {
        if (mod.type !== 'dir') continue;
        const modPath = `${basePath}/${mod.name}`;
        const modContents = await fetchRepoContents(modPath);
        if (!modContents || !Array.isArray(modContents)) continue;

        let modJson = null, modTxt = null, imageUrl = null, langFiles = [];

        for (const file of modContents) {
            if (file.name === 'mod.json') {
                try { 
                    const jsonResponse = await fetch(`${rawBaseUrl}/${modPath}/mod.json`);
                    if (jsonResponse.ok) modJson = await jsonResponse.json();
                } catch(e) { console.error(e); }
            } else if (file.name === 'mod.txt') {
                try { const txtResponse = await fetch(`${rawBaseUrl}/${modPath}/mod.txt`); if (txtResponse.ok) modTxt = await txtResponse.text(); } catch(e) {}
            } else if (file.name === 'image.jpeg') { imageUrl = `${rawBaseUrl}/${modPath}/image.jpeg`; }
            else if (file.name === 'lang' && file.type === 'dir') {
                const langPath = `${modPath}/lang`;
                const langContents = await fetchRepoContents(langPath);
                if (langContents) langFiles = langContents.map(f => ({author: f.name.replace('.json',''), url:`${rawBaseUrl}/${langPath}/${f.name}`}));
            }
        }

        if (modJson && modTxt && imageUrl) {
            const [name, description, modrinthLink] = modTxt.trim().split('\n');
            
            // modJson - це масив об'єктів, кожен з яких представляє окремий варіант мода
            const versionsArr = modJson.map(v => v.version);
            const loadersArr = modJson.map(v => v.loader);
            const authorsArr = modJson.map(v => v.author);

            // Додати у множини для фільтрів
            versionsArr.forEach(v => allVersions.add(v));
            loadersArr.forEach(l => allCores.add(l));
            authorsArr.forEach(a => allAuthors.add(a));

            // Видалити дублікати з loadersArr
            const uniqueLoaders = [...new Set(loadersArr)];
            const loadersDisplay = uniqueLoaders.join(' - ');

            // Зберігаємо дані про мод
            const modData = {
                name,
                description,
                modrinthLink,
                versions: versionsArr,
                loaders: uniqueLoaders,
                authors: authorsArr,
                modJson, // Це масив об'єктів
                langFiles,
                imageUrl
            };
            modsData.push(modData);

            const card = document.createElement('div');
            card.className = 'mod-card';
            card.dataset.name = name.toLowerCase();
            card.dataset.versions = versionsArr.join(' ').toLowerCase();
            card.dataset.loaders = uniqueLoaders.join(' ').toLowerCase();
            card.dataset.authors = authorsArr.join(' ').toLowerCase();
            card.dataset.modIndex = modsData.length - 1;
            card.innerHTML = `
                <img src="${imageUrl}" alt="${name}">
                <h2>${name}</h2>
                <p>${description}</p>
                <p><a href="${modrinthLink}" target="_blank">Modrinth сторінка</a></p>
                <p>Версія: ${versionsArr.join(', ')}</p>
                <p>(${loadersDisplay})</p>
            `;
            
            const selectButton = document.createElement('button');
            selectButton.textContent = 'Вибрати переклад';
            selectButton.addEventListener('click', () => showSelectModal(modJson, langFiles, name));
            card.appendChild(selectButton);
            modListDiv.appendChild(card);
        }
    }

    populateFilterOptions();
}

// Заповнити фільтри
function populateFilterOptions() {
    const vSelect = document.getElementById('filter-version');
    const cSelect = document.getElementById('filter-core');
    const aSelect = document.getElementById('filter-author');

    [...allVersions].sort().forEach(v => { const opt = document.createElement('option'); opt.value = v; opt.textContent = v; vSelect.appendChild(opt); });
    [...allCores].sort().forEach(c => { const opt = document.createElement('option'); opt.value = c; opt.textContent = c; cSelect.appendChild(opt); });
    [...allAuthors].sort().forEach(a => { const opt = document.createElement('option'); opt.value = a; opt.textContent = a; aSelect.appendChild(opt); });
}

// Функція для створення ZIP файлу з перекладом
async function createTranslationZip(modData, selectedVersion, selectedLoader, selectedAuthor) {
    const zip = new JSZip();
    
    // Знаходимо відповідний mod.json з масиву об'єктів
    const modConfig = modData.modJson.find(m => 
        m.version === selectedVersion && m.loader === selectedLoader
    );
    
    if (modConfig) {
        // Створюємо mod.json з вибраною конфігурацією
        zip.file('mod.json', JSON.stringify(modConfig, null, 2));
    }
    
    // Додаємо файл перекладу
    const langFile = modData.langFiles.find(f => f.author === selectedAuthor);
    if (langFile) {
        try {
            const response = await fetch(langFile.url);
            if (response.ok) {
                const langContent = await response.text();
                zip.file('lang/uk_ua.json', langContent);
            }
        } catch (e) {
            console.error('Error fetching lang file:', e);
        }
    }
    
    // Створюємо та завантажуємо ZIP
    const blob = await zip.generateAsync({type: 'blob'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${modData.name}_${selectedVersion}_${selectedLoader}_${selectedAuthor}.zip`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Функція для перевірки кількості варіантів перекладу
function getAvailableTranslations(modData, versionFilter, coreFilter) {
    if (!modData) return [];
    
    // modData.modJson - це масив об'єктів, кожен об'єкт - це окремий варіант мода
    let availableConfigs = modData.modJson;
    
    // Фільтруємо за версією та ядром
    if (versionFilter) {
        availableConfigs = availableConfigs.filter(config => 
            config.version.toLowerCase() === versionFilter.toLowerCase()
        );
    }
    
    if (coreFilter) {
        availableConfigs = availableConfigs.filter(config => 
            config.loader.toLowerCase() === coreFilter.toLowerCase()
        );
    }
    
    // Створюємо список всіх можливих комбінацій
    const translations = [];
    
    for (const modConfig of availableConfigs) {
        for (const langFile of modData.langFiles) {
            translations.push({
                version: modConfig.version,
                loader: modConfig.loader,
                author: langFile.author
            });
        }
    }
    
    return translations;
}

// Функція для показу модального вікна вибору перекладу
function showSelectModal(modJson, langFiles, modName) {
    // Отримуємо поточні фільтри
    const versionFilter = document.getElementById('filter-version').value.toLowerCase();
    const coreFilter = document.getElementById('filter-core').value.toLowerCase();
    
    // Створюємо модальне вікно
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background: white;
        padding: 20px;
        border-radius: 8px;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
    `;
    
    // Додаємо інформацію про фільтри
    const filterInfo = [];
    if (versionFilter) filterInfo.push(`Версія: ${versionFilter}`);
    if (coreFilter) filterInfo.push(`Ядро: ${coreFilter}`);
    const filterText = filterInfo.length > 0 ? ` (Фільтр: ${filterInfo.join(', ')})` : '';
    
    modalContent.innerHTML = `
        <h2>Виберіть варіант перекладу для ${modName}${filterText}</h2>
        <div id="translation-options"></div>
        <button onclick="this.closest('.modal').remove()" style="margin-top: 10px;">Закрити</button>
    `;
    
    const optionsContainer = modalContent.querySelector('#translation-options');
    
    // modJson - це масив об'єктів, кожен об'єкт - це окремий варіант мода
    // Фільтруємо варіанти відповідно до поточних фільтрів
    let configsToShow = modJson;
    
    if (versionFilter || coreFilter) {
        console.log('Фільтри активні:', { versionFilter, coreFilter });
        console.log('Всі конфігурації:', modJson);
        
        configsToShow = modJson.filter(modConfig => {
            const matchesVersion = !versionFilter || modConfig.version.toLowerCase() === versionFilter;
            const matchesLoader = !coreFilter || modConfig.loader.toLowerCase() === coreFilter;
            console.log(`Перевірка ${modConfig.version}/${modConfig.loader}:`, { matchesVersion, matchesLoader });
            return matchesVersion && matchesLoader;
        });
        
        console.log('Відфільтровані конфігурації:', configsToShow);
    }
    
    // Якщо після фільтрації немає варіантів, показуємо повідомлення
    if (configsToShow.length === 0) {
        optionsContainer.innerHTML = `
            <p style="color: #666; text-align: center; padding: 20px;">
                Немає варіантів перекладу для вибраних фільтрів.<br>
                Спробуйте змінити фільтри або виберіть інший мод.
            </p>
        `;
    } else {
        // Створюємо опції тільки для відфільтрованих варіантів
        for (const modConfig of configsToShow) {
            // Для кожного варіанту мода показуємо всі доступні файли перекладів
            for (const langFile of langFiles) {
                const optionDiv = document.createElement('div');
                optionDiv.style.cssText = `
                    border: 1px solid #ddd;
                    margin: 10px 0;
                    padding: 10px;
                    border-radius: 4px;
                `;
                
                optionDiv.innerHTML = `
                    <p><strong>Версія:</strong> ${modConfig.version}</p>
                    <p><strong>Ядро:</strong> ${modConfig.loader}</p>
                    <p><strong>Автор перекладу:</strong> ${langFile.author}</p>
                    <button onclick="downloadTranslation('${modName}', '${modConfig.version}', '${modConfig.loader}', '${langFile.author}')" 
                            style="background: #4CAF50; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">
                        Завантажити
                    </button>
                `;
                
                optionsContainer.appendChild(optionDiv);
            }
        }
    }
    
    modal.appendChild(modalContent);
    modal.className = 'modal';
    document.body.appendChild(modal);
}

// Функція для завантаження перекладу з модального вікна
async function downloadTranslation(modName, version, loader, author) {
    const modData = modsData.find(m => m.name === modName);
    if (modData) {
        await createTranslationZip(modData, version, loader, author);
        // Закриваємо модальне вікно
        document.querySelector('.modal').remove();
    }
}

// Фільтрація + пошук по назві
function filterMods() {
    const search = document.getElementById('search-input').value.toLowerCase();
    const versionFilter = document.getElementById('filter-version').value.toLowerCase();
    const coreFilter = document.getElementById('filter-core').value.toLowerCase();
    const authorFilter = document.getElementById('filter-author').value.toLowerCase();

    document.querySelectorAll('.mod-card').forEach(card => {
        const name = card.dataset.name;
        const versions = card.dataset.versions;
        const loaders = card.dataset.loaders;
        const authors = card.dataset.authors;
        const modIndex = parseInt(card.dataset.modIndex);

        // Перевіряємо чи мод має вибрану версію та ядро
        const hasVersion = versionFilter === '' || versions.includes(versionFilter);
        const hasLoader = coreFilter === '' || loaders.includes(coreFilter);
        const hasAuthor = authorFilter === '' || authors.includes(authorFilter);
        const hasName = name.includes(search);

        if (hasName && hasVersion && hasLoader && hasAuthor) {
            card.classList.remove('hidden');
            
            // Якщо вибрана конкретна версія або ядро, перевіряємо чи потрібно змінити кнопку
            if (versionFilter !== '' || coreFilter !== '') {
                const button = card.querySelector('button');
                if (button) {
                    const modData = modsData[modIndex];
                    const availableTranslations = getAvailableTranslations(modData, versionFilter, coreFilter);
                    
                    if (availableTranslations.length === 1) {
                        // Тільки один варіант - змінюємо кнопку на "Завантажити"
                        button.textContent = 'Завантажити';
                        button.onclick = () => {
                            const translation = availableTranslations[0];
                            createTranslationZip(modData, translation.version, translation.loader, translation.author);
                        };
                    } else {
                        // Кілька варіантів - повертаємо оригінальну кнопку
                        button.textContent = 'Вибрати переклад';
                        button.onclick = () => showSelectModal(modData.modJson, modData.langFiles, modData.name);
                    }
                }
            }
        } else {
            card.classList.add('hidden');
        }
    });
}

loadMods().then(() => {
    document.getElementById('search-input').addEventListener('input', filterMods);
    document.getElementById('filter-version').addEventListener('change', filterMods);
    document.getElementById('filter-core').addEventListener('change', filterMods);
    document.getElementById('filter-author').addEventListener('change', filterMods);
    
    // Додаємо функціональність для кнопки "Об'єднати мод"
    document.getElementById('combine-open').addEventListener('click', showCombineModal);
});

// Функція для показу модального вікна об'єднання модів
function showCombineModal() {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background: white;
        padding: 20px;
        border-radius: 8px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
    `;
    
    modalContent.innerHTML = `
        <h2>Об'єднати моди</h2>
        <p>Виберіть моди для об'єднання в один ZIP файл:</p>
        <div id="combine-options"></div>
        <button onclick="combineSelectedMods()" style="background: #4CAF50; color: white; border: none; padding: 10px 15px; border-radius: 4px; margin: 10px 5px; cursor: pointer;">
            Об'єднати вибрані
        </button>
        <button onclick="this.closest('.modal').remove()" style="background: #f44336; color: white; border: none; padding: 10px 15px; border-radius: 4px; margin: 10px 5px; cursor: pointer;">
            Закрити
        </button>
    `;
    
    const optionsContainer = modalContent.querySelector('#combine-options');
    
    // Показуємо тільки видимі моди
    const visibleMods = Array.from(document.querySelectorAll('.mod-card:not(.hidden)'));
    
    visibleMods.forEach((card, index) => {
        const modIndex = parseInt(card.dataset.modIndex);
        const modData = modsData[modIndex];
        
        const optionDiv = document.createElement('div');
        optionDiv.style.cssText = `
            border: 1px solid #ddd;
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        `;
        
        optionDiv.innerHTML = `
            <input type="checkbox" id="mod-${index}" data-mod-index="${modIndex}">
            <label for="mod-${index}">
                <strong>${modData.name}</strong> - ${modData.versions.join(', ')} (${modData.loaders.join(' - ')})
            </label>
        `;
        
        optionsContainer.appendChild(optionDiv);
    });
    
    modal.appendChild(modalContent);
    modal.className = 'modal';
    document.body.appendChild(modal);
}

// Функція для об'єднання вибраних модів
async function combineSelectedMods() {
    const selectedCheckboxes = document.querySelectorAll('#combine-options input[type="checkbox"]:checked');
    
    if (selectedCheckboxes.length === 0) {
        alert('Виберіть хоча б один мод для об\'єднання');
        return;
    }
    
    const zip = new JSZip();
    const selectedMods = [];
    
    for (const checkbox of selectedCheckboxes) {
        const modIndex = parseInt(checkbox.dataset.modIndex);
        const modData = modsData[modIndex];
        selectedMods.push(modData);
        
        // Додаємо mod.json для першого мода (якщо є)
        if (modData.modJson.length > 0) {
            zip.file(`${modData.name}/mod.json`, JSON.stringify(modData.modJson[0], null, 2));
        }
        
        // Додаємо всі файли перекладів
        for (const langFile of modData.langFiles) {
            try {
                const response = await fetch(langFile.url);
                if (response.ok) {
                    const langContent = await response.text();
                    zip.file(`${modData.name}/lang/${langFile.author}.json`, langContent);
                }
            } catch (e) {
                console.error(`Error fetching lang file for ${modData.name}:`, e);
            }
        }
    }
    
    // Створюємо та завантажуємо ZIP
    const blob = await zip.generateAsync({type: 'blob'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `combined_mods_${selectedMods.map(m => m.name).join('_')}.zip`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Закриваємо модальне вікно
    document.querySelector('.modal').remove();
}
</script>
</body>
</html>
